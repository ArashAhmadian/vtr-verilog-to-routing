#This is a script to parse in path_info generated by Quartus Timing analyzer to extract routing information.



import os as os 
import sys as sys 
from uuid import NAMESPACE_DNS
import numpy as np 
import matplotlib as plt
import pandas as pd
import sklearn.metrics as sk

"""" 
    Assumption 1: Wire delay does grows linearly with length. This inherently assumes that resistance and capacitance of the wire stay 
    constant since T_p=sum(R_kk*C_k) refer to: http://bwrcs.eecs.berkeley.edu/Classes/icdesign/ARCHIVE/sig_del_rc_net.pdf for details. :)
    
    Assumption 2: All inherent propagation delays from wires inside blocks are ignored when calculating routing delays. i.e. we don't take into    
    acount the delay of input/output wire connected pin driving a/driven by a connection block mux. 
    
    Switch block values area stored in an n x n matrix (sb_matrix) where n is the number of wire types -1 (len(wire_types)-1). Since we aim to 
    *approximate* the switch block values, we assume that the delay values for various input-output combinations are different, depending
    on both wire type and order. To model sb's is VTR, one could manually average out these values/simplify these approximations by 
    grouping similar delays together modelling them as a wire switch. Or, define multiple drivers to cover all combination.
    If a specific combination is not found, the corresponding matrix element is set to 0. 
    The matrix format is as follows:
    
    [sb_00  sb_01 ...  sb_0n
     sb_10  sb_11 ...  sb_1n
        .     .    .     .
        .     .    .     .
     sb_n0  sb_n1 ...  sb_nn*]
     
     *sb_nn = sb_{input_wire_type_index,output_wire_type_index}
      
     Connection block values are stored a vector of size n. To model cb's in VTR, one should manually group sensible wire types together
     and model as one mux. If a specific connection is not found, it's corresponding element is set to 0. 
     
     
     [cb_0  cb_1 ... cb_n]
     
     
"""
class Route_line:
    def __init__(self,line_index,contents,wire_types):
        line=contents[line_index]
        self.index=line_index
        self.line=line.replace(" ","")
        temp_list=self.line.split(";")
        self.X=None 
        self.Y=None 
        self.delay=None 
        if (len(temp_list)==9 and temp_list[4]=='RE'): 
            #print("here")
            self.type=None 
            self.re=True 
            self.delay=float(temp_list[2])
            self.routing_element=temp_list[6]
            if temp_list[7]=='WIRE_MUX':
                self.type='WIRE_MUX'
            elif temp_list[7].find('leim')!=-1:
                self.type='LEIM'
            elif temp_list[7]=='MP_LAB_COMB': 
                self.type="MP_LAB_COMB"                                                                                  "
            for type in wire_types:
                if temp_list[7]==type: 
                    #print(type)
                    self.type=type

            t_list=self.routing_element.split('_')
            for piece in t_list:
                if piece.find('X')==0: 
                    self.X=float(piece[1:])
                elif piece.find('Y')==0:
                    self.Y=float(piece[1:])
            if self.delay==0 and self.re==True and self.type is None:
                self.type="PATH_START"
        else: 
            self.re=False
            self.delay=None
            self.routing_element=None
            self.type=None 
            
        self.distance=None 
        self.switch_type=None 
    
    def fill_switch_type(self,path_lines):
        if (self.type=='LAB_LINE'):
            if path_lines[self.index-1].re is True and path_lines[self.index-1].type is not None:
                if (path_lines[self.index-1].type=='WIRE_MUX' ):
                    if (path_lines[self.index-2] is not None):
                        self.switch_type=path_lines[self.index-2].type
                        return 'I'
                    else: 
                        return None 
                else: 
                    self.switch_type=path_lines[self.index-1].type
                    return 'I'
                
            else: 
                return None 

        elif (self.type=='LAB_RE'):
            if path_lines[self.index+1].re is True and path_lines[self.index+1].type is not None:
                if (path_lines[self.index+1].type=='WIRE_MUX'):
                    if (path_lines[self.index+2].type is not None):
                        self.switch_type=path_lines[self.index+2].type
                        return 'O'
                    else: 
                        return None
                elif (path_lines[self.index+1].type == "PATH_START"):
                        return None  
                else: 
                    self.switch_type=path_lines[self.index+1].type
                    return 'O'
            else: 
                return None 
        elif (self.type=='LEIM'):
            if path_lines[self.index-1].type=='LAB_LINE':
                self.switch_type=path_lines[self.index].type
                return'L'
            else: 
                return None 
        elif (self.type=='V2' or self.type=='V3' or
            self.type=='V4' or self.type=='V16'or 
            self.type=='H24'or self.type=='H4' or 
            self.type=='H10'or self.type=='H2'): 
            if (path_lines[self.index-1].type=='WIRE_MUX'):
                if (path_lines[self.index-2].type is not None):
                    self.switch_type=path_lines[self.index-2].type+'_'+self.type
        
            elif(path_lines[self.index-1].type is  None or path_lines[self.index-1].type=='LAB_RE'): 
                pass
            elif(self.type=="PATH_START"):
                pass 
            else:
                self.switch_type=path_lines[self.index-1].type+'_'+self.type 

            return ''

    def fill_distance (self,path_lines):
        if (self.type=='V2' or self.type=='V3' or
            self.type=='V4' or self.type=='V16'): 
            if (path_lines[self.index-1].Y is not None and path_lines[self.index-1].Y > self.Y): 
                self.distance=path_lines[self.index-1].Y-self.Y
            elif (path_lines[self.index+1].Y is not None and path_lines[self.index+1].Y>self.Y): 
                self.distance=path_lines[self.index+1].Y-self.Y 
            else:
                self.distance=0 
        elif (self.type=='H24' or self.type=='H4' or
            self.type=='H10' or self.type=='H2'):
            if (path_lines[self.index-1].X is not None and path_lines[self.index-1].X > self.X): 
                self.distance=path_lines[self.index-1].X-self.X
            elif (path_lines[self.index+1].X is not None and path_lines[self.index+1].X>self.X): 
                self.distance=path_lines[self.index+1].X-self.X 
            else: 
                self.distance=0 
        else: 
            self.distance=None 

r=open('paths_dump_region2_pairs_only_20000.ascii','r')
contents=r.readlines()
'''rr=open('paths_dump_region1_pairs_only_150000.ascii','r')
contents1=rr.readlines()
contents+=contents1
rr.close()
rr=open('paths_dump_region3_pairs_only_200000.ascii','r')
contents1=rr.readlines()
contents+=contents1
rr.close()
'''   

wire_types=['V2','V3','V4','V16','H24','H4','H10','H2','LAB_RE','LAB_LINE']
dict={'V2':0,'V3':1,'V4':2,'V16':3,'H24':4,'H4':5,'H10':6,'H2':7,'LAB_RE':8,'LAB_LINE':9}
#LAB_LINE is when the wire is the input, so when a conenction block is used as to connect to the input of block i.e. wire->block
#LAB_RE is when the wire is the output, so when a connection block is used to connect to the output of the block i.e. block->wire 

#LEIM 
leim_results=0
leim_delay=0 
leim_count=0 
#VECTOR SWITCH BLOCK DELAYS
sb_results=[0]*10
sb_delays=[0]*10
sb_count=[0]*10
#MATRIX SWITCH BLOCK DELAYS
np.set_printoptions(suppress=True)
sb_results_matrix=np.zeros(shape=(8,8))
sb_count_matrix=np.zeros(shape=(8,8))
sb_delay_matrix=np.zeros(shape=(8,8))
#LAB_LINE
cbi_results=[0]*10
cbi_delays=[0]*10
cbi_count=[0]*10
#LAB_RE
cbo_results=[0]*10
cbo_delays=[0]*10
cbo_count=[0]*10


path_lines=[]
for line_index in range(len(contents)):
    routing_line=Route_line(line_index,contents,wire_types)
    path_lines.append(routing_line)

for line in path_lines:
    if line.re is True and line.type is not None: 
        switch_result=line.fill_switch_type(path_lines)
        line.fill_distance(path_lines)
        if (switch_result=='I'):
            if line.delay >0: 
                cbi_delays[dict[line.switch_type]]=cbi_delays[dict[line.switch_type]]+line.delay
                cbi_count[dict[line.switch_type]]=cbi_count[dict[line.switch_type]]+1
        elif(switch_result=='O'):
            if line.delay >0: 
                cbo_delays[dict[line.switch_type]]=cbo_delays[dict[line.switch_type]]+line.delay
                cbo_count[dict[line.switch_type]]=cbo_count[dict[line.switch_type]]+1
        elif (switch_result=='L'):
            if line.delay >0:
                leim_delay=leim_delay+line.delay
                leim_count=leim_count+1
        elif(switch_result==''):
            if line.delay >0: 
                sb_delays[dict[line.type]]=sb_delays[dict[line.type]]+line.delay 
                sb_count[dict[line.type]]=sb_count[dict[line.type]]+1
                if (line.switch_type is not None):
                    temp=line.switch_type.split('_')
                    #print(line.switch_type,":",temp[0],":",temp[1]) 
                    sb_delay_matrix[dict[temp[0]]][dict[temp[1]]]=sb_delay_matrix[dict[temp[0]]][dict[temp[1]]]+line.delay
                    sb_count_matrix[dict[temp[0]]][dict[temp[1]]]=sb_count_matrix[dict[temp[0]]][dict[temp[1]]]+1.0
    
    else: 
        continue 

for index in range(len(sb_delays)):
    if sb_count[index] !=0: 
        sb_results[index]=sb_delays[index]/sb_count[index]
    if cbi_count[index] !=0:
        cbi_results[index]=cbi_delays[index]/cbi_count[index]
    if cbo_count[index] !=0:
        cbo_results[index]=cbo_delays[index]/cbo_count[index]

leim_results=leim_delay/leim_count

if __name__=="__main__":

    if os.path.exists('wire_spread_nxn.csv'):
        os.remove('wire_spread_nxn.csv')

    if os.path.exists('wire_spread_1D.csv'):
        os.remove('wire_spread_1D.csv')

    for i in wire_types:
        if os.path.exists(i+'_points.csv'):
            os.remove(i+'_points.csv')
        for j in wire_types:
            if os.path.exists(i+'_'+j+'_'+'points.csv'):
                os.remove(i+'_'+j+'_'+'points.csv')


    w=open('distance_0_wires.ascii','w')
    spread_file=open('wire_spread_nxn.csv','a')
    spread_file_1D=open('wire_spread_1D.csv','w')
      
    
    #w=open('C:\\Users\\arash\\Desktop\\Arash\\results_R10_pairs_only.txt','w')


    sb_results_matrix=np.true_divide(sb_delay_matrix,sb_count_matrix)

    leim_spread=[0]*5
    cbi_avg=0
    cbo_avg=0

    spread=[]
    spread_1D=[]
    for i in range(8):
        temp=[]
        for j in range(5):
            temp.append(0)
        spread_1D.append(temp)

    for i in range(8):
        temp1=[]
        for j in range(8):
            temp2=[]
            for k in range(5):
                temp2.append(0)
            temp1.append(temp2)
        spread.append(temp1)

    for index in range(len(sb_delays)-2):
        cbi_avg=cbi_avg+cbi_results[index]
        cbi_avg=cbi_avg+cbi_results[index]
    cbi_avg=cbi_avg/(len(cbi_count)-4)
    cbo_avg=cbo_avg/(len(cbo_count)-4)

    for line in path_lines:
        if (line.type=='LEIM'):
            diff_percent=(abs(line.delay-leim_results)/leim_results)*100
            if (diff_percent<5):
                leim_spread[0]=leim_spread[0]+1
            elif (diff_percent<10):
                leim_spread[1]=leim_spread[1]+1
            elif (diff_percent<20):
                leim_spread[2]=leim_spread[2]+1
            elif (diff_percent<50):
                leim_spread[3]=leim_spread[3]+1
            elif (diff_percent>50):
                leim_spread[4]=leim_spread[4]+1
        for type in wire_types[:8]:
            if line.type==type and line.delay is not None: 
                diff_percent_1D=(abs(line.delay-sb_results[dict[type]]))/sb_results[dict[type]]*100
                if (diff_percent_1D <5): 
                    spread_1D[dict[type]][0]+=1
                elif(diff_percent_1D <10):
                    spread_1D[dict[type]][1]+=1
                elif(diff_percent_1D <20):
                    spread_1D[dict[type]][2]+=1
                elif(diff_percent_1D <50):
                    spread_1D[dict[type]][3]+=1
                elif(diff_percent_1D >50):
                    spread_1D[dict[type]][4]+=1
                
                if line.switch_type is not None:
                    temp_list=line.switch_type.split('_')
                    if sb_results_matrix[dict[temp_list[0]]][dict[temp_list[1]]]!=0: 
                        diff_percent=(abs(line.delay-sb_results_matrix[dict[temp_list[0]]][dict[temp_list[1]]])/sb_results_matrix[dict[temp_list[0]]][dict[temp_list[1]]])*100
                    else:
                        spread[dict[temp_list[0]]][dict[temp_list[1]]]=[0]*5
                        continue

                    if (diff_percent <5): 
                        spread[dict[temp_list[0]]][dict[temp_list[1]]][0]=spread[dict[temp_list[0]]][dict[temp_list[1]]][0]+1
                    elif (diff_percent <10):
                        spread[dict[temp_list[0]]][dict[temp_list[1]]][1]=spread[dict[temp_list[0]]][dict[temp_list[1]]][1]+1    
                    elif (diff_percent <20):
                        spread[dict[temp_list[0]]][dict[temp_list[1]]][2]=spread[dict[temp_list[0]]][dict[temp_list[1]]][2]+1
                    elif (diff_percent <50):
                        spread[dict[temp_list[0]]][dict[temp_list[1]]][3]=spread[dict[temp_list[0]]][dict[temp_list[1]]][3]+1
                    elif (diff_percent >50):
                        spread[dict[temp_list[0]]][dict[temp_list[1]]][4]=spread[dict[temp_list[0]]][dict[temp_list[1]]][4]+1
                
    for i in range(8):
        for k in range(8):
            total=0
            for j in range(5):
                total=total+spread[i][k][j]
            for j in range(5):
                if total!=0:
                    spread[i][k][j]=spread[i][k][j]/total*100
                else:
                    spread[i][k][j]=0 
    for i in range(8):
        total=0
        for j in range(5):
            total+=spread_1D[i][j]
        for j in range (5):
            spread_1D[i][j]=spread_1D[i][j]/total*100

    total=0
    for i in range(5):
        total=total+leim_spread[i]
    for i in range(5):
        leim_spread[i]=leim_spread[i]/total


    arr=np.array

    for i in range(8):
        diff_arr=np.array(spread[i])
        spread_file.write('\n'+wire_types[i]+'as input:\n')
        diff_df=pd.DataFrame(diff_arr,index=wire_types[:8],columns=['<%5','<%10','<20%','<50%','>50%'])
        diff_df.to_csv(path_or_buf=spread_file,na_rep='nan',line_terminator="")
        file_out=r'wire_spread_nxn.csv'
        file_data = open(file_out, 'rb').read()
        open(file_out, 'wb').write(file_data[:-2])




    #print(sb_delay_matrix)
    print(sb_count_matrix)
    #print(sb_results_matrix)

    
    print("LEIM SPREAD:",leim_spread)


    ddt=pd.DataFrame(sb_delay_matrix,index=wire_types[:8],columns=wire_types[:8])
    ddt1=pd.DataFrame(sb_count_matrix,index=wire_types[:8],columns=wire_types[:8])
    f_mean=ddt.sum(axis=0).div(ddt1.sum(axis=0))

    ddt1=pd.DataFrame(sb_results_matrix,index=wire_types[:8],columns=wire_types[:8])
    mean=ddt1.sum(axis=0,skipna=True).divide(8)
    mean=mean.rename('Weighted Mean')
    f_mean=f_mean.rename('Mean')
    ddt=pd.DataFrame(sb_results_matrix,index=wire_types[:8],columns=wire_types[:8])
    ddt=ddt.append(f_mean,ignore_index=False)

    ddt.to_csv(path_or_buf="nxn_sb_10k_new.csv",na_rep='nan')
    ddt=pd.DataFrame(spread_1D,columns=['<%5','<%10','<20%','<50%','>50%'],index=wire_types[:8])
    ddt.to_csv(path_or_buf=spread_file_1D,na_rep='nan')

    for line in path_lines: 
        if line.re is True and line.type is not None: 
            if (line.switch_type is not None and 
                (line.type=='V2' or line.type=='V3' or
                line.type=='V4' or line.type=='V16'or 
                line.type=='H24'or line.type=='H4' or 
                line.type=='H10'or line.type=='H2')):

                nxn_path=line.switch_type+'_points.csv'
                n_path=line.type+'_points.csv'
                nxn_file=open(nxn_path,'a')
                n_file=open(n_path,'a')

                if line.distance==0: 
                    before=path_lines[line.index-1]
                    after=path_lines[line.index+1]
                    print(before.routing_element,file=w)
                    print(line.routing_element,file=w)
                    print(after.routing_element,file=w)
                    print('==============================================\n',file=w)

                arr_n_=np.array([line.delay,line.distance])
                np.savetxt(nxn_file,arr_n_.reshape(1,arr_n_.shape[0]),delimiter=',')
                np.savetxt(n_file,arr_n_.reshape(1,arr_n_.shape[0]),delimiter=',')
                nxn_file.close()
                n_file.close()

    NMAE_matrix=np.zeros(shape=(8,8))
    NRMSE_matrix=np.zeros(shape=(8,8))
    NRMSE_1d_using_1d_sb=np.zeros(8)
    NMAE_1d_using_1d_sb=np.zeros(8)
    NRMSE_1d_using_weighted_means=np.zeros(8)
    NMAE_1d_using_weighted_means=np.zeros(8)
    NMAE_1d_using_nxn_means=np.zeros(8)
    NRMSE_1d_using_nxn_means=np.zeros(8)


    for type in wire_types[:8]:
        p_1=type+"_points.csv"
        ddt1=pd.read_csv(p_1,names=['Delay','Distance'])
        ddt1['Mean']=sb_results[dict[type]]
        ddt1['Weighted_Mean']=f_mean[type]
        y=ddt1[['Delay']]
        yp=ddt1.Mean
        ypw=ddt1.Weighted_Mean
        NRMSE_1d_using_1d_sb[dict[type]]=sk.mean_squared_error(y,yp,squared=False)/sb_results[dict[type]]*100
        NMAE_1d_using_1d_sb[dict[type]]=sk.mean_absolute_error(y,yp)/sb_results[dict[type]]*100
        NRMSE_1d_using_weighted_means[dict[type]]=sk.mean_squared_error(y,ypw,squared=False)/f_mean[type]*100
        NMAE_1d_using_weighted_means[dict[type]]=sk.mean_absolute_error(y,ypw)/f_mean[type]*100
        ddt1=pd.DataFrame(columns=['Delay','Distance','Mean'])

        for type_ in wire_types[:8]:
            p=type_+'_'+type+'_points.csv'
            if os.path.exists(type_+'_'+type+'_points.csv'):
                ddt=pd.read_csv(p,names=['Delay','Distance'])
                ddt['Mean']=sb_results_matrix[dict[type_]][dict[type]]
                ddt1=ddt1.append(ddt)
                y=ddt[['Delay']]
                yp=ddt.Mean
                NMAE_matrix[dict[type_]][dict[type]]=sk.mean_absolute_error(y,yp)/sb_results_matrix[dict[type_]][dict[type]]*100
                NRMSE_matrix[dict[type_]][dict[type]]=sk.mean_squared_error(y,yp,squared=False)/sb_results_matrix[dict[type_]][dict[type]]*100

        y=ddt1[['Delay']]
        ypn=ddt1.Mean
        NRMSE_1d_using_nxn_means[dict[type]]=sk.mean_squared_error(y,ypn,squared=False)/f_mean[type]*100
        NMAE_1d_using_nxn_means[dict[type]]=sk.mean_absolute_error(y,ypn)/f_mean[type]*100

    if os.path.exists("error_file.csv"): 
        os.remove("error_file.csv") 
    error_file=open("error_file.csv",'a')
    print("Normalized Mean Absolute Error (nxn):\n",file=error_file)
    ddt=pd.DataFrame(NMAE_matrix,columns=wire_types[:8],index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')
    print("Normalized Mean Absolute Error using sb_nxn means as prediction (n):\n",file=error_file)
    ddt=pd.Series(NMAE_1d_using_1d_sb,index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')
    print("Normalized Mean Absolute Error using sb_nxn weighted means as prediction (n):\n",file=error_file)
    ddt=pd.Series(NMAE_1d_using_weighted_means,index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')
    print("Normalized Mean Absolute Error using sb_nxn values as prediction (n):\n",file=error_file)
    ddt=pd.Series(NMAE_1d_using_nxn_means,index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')

    print("Normalized Root Mean Squared Error (nxn): \n", file=error_file)
    ddt=pd.DataFrame(NRMSE_matrix,columns=wire_types[:8],index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')
    print("Normalized Root Mean Sqaured Error using sb_nxn means as prediction (n):\n",file=error_file)
    ddt=pd.Series(NRMSE_1d_using_1d_sb,index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')
    print("Normalized Root Mean Sqaured Error using sb_nxn weighted means as prediction (n):\n",file=error_file)
    ddt=pd.Series(NRMSE_1d_using_weighted_means,index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')
    print("Normalized Root Mean Sqaured Error using sb_nxn values as prediction (n):\n",file=error_file)
    ddt=pd.Series(NRMSE_1d_using_nxn_means,index=wire_types[:8])
    ddt.to_csv(path_or_buf=error_file,na_rep='nan')
    error_file.close()


    print(sb_results_matrix)
    print(sb_delay_matrix)
    print(sb_count_matrix)
    print("fmean=\n",f_mean)
    print("mean=\n",mean)
    #print(cbi_results)
    #print(cbo_results)



    #print("cbi_delay:",cbi_avg)
    #print("cbo_delay:",cbo_avg)
    print("leim delay",leim_results)

    r.close()
    w.close()
    spread_file_1D.close()
    spread_file.close()
